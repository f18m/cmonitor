#!/usr/bin/python3

#
# cmonitor_loader.py
#
# Author: Francesco Montorsi
# Created: January 2022
#

import json
import os
import sys
import gzip


# =======================================================================================================
# CmonitorCollectorJsonLoader
# =======================================================================================================
class CmonitorCollectorJsonLoader:
    def __init__(self):
        self.input_file = ""
        self.this_tool_version = ""
        self.validated_json = None

    def load(self, infile, this_tool_version, min_num_samples=2, be_verbose=False):
        """
        This function is able to read both JSON files produced by cmonitor_collector and
        compressed JSON.GZ files. If 'infile' is '-' then input is read from stdin.
        Moreover this function is also tolerant to unfinished JSON files (i.e. files in which
        cmonitor_collector is still appending data).
        Finally it also performs very basic validation of JSON structure.
        Returns the JSON structure of the document.
        """

        self.input_file = infile
        self.this_tool_version = this_tool_version
        self.validated_json = None  # set only at the end, if successful

        # read the raw .json as text
        try:
            if infile == "-":
                # read from stdin
                if be_verbose:
                    print("Loading JSON file from stdin")
                text = sys.stdin.read()
            elif infile[-8:] == ".json.gz":
                if be_verbose:
                    print("Loading gzipped JSON file %s" % infile)
                f = gzip.open(infile, "rb")
                text = f.read()
                f.close()

                # in Python 3.5 the gzip returns a sequence of "bytes" and not a "str"
                if isinstance(text, bytes):
                    text = text.decode("utf-8")
            else:
                if be_verbose:
                    print("Loading JSON file %s" % infile)
                f = open(infile, "r")
                text = f.read()
                f.close()
        except OSError as err:
            print("Error while opening input JSON file '%s': %s" % (infile, err))
            sys.exit(1)

        # Convert the text to json and extract the samples
        try:
            entry = json.loads(text)  # convert text to JSON
        except json.decoder.JSONDecodeError as err:
            # fix up the end of the file if it is not complete
            if text[-1] == ",":
                # try removing last comma
                text[-1] = " "
            # add the closure of the "samples" array and JSON end-of-object
            try:
                entry = json.loads(text + "]}")
            except json.decoder.JSONDecodeError as err:
                print("Invalid input JSON file '%s': %s" % (infile, err))
                sys.exit(1)

        try:
            jheader = entry["header"]
            jdata = entry["samples"]  # removes outer parts so we have a list of snapshot dictionaries
        except:
            print("Unexpected JSON format. Aborting.")
            sys.exit(1)

        # Check if cmonitor_collector version used differs or not:
        try:
            cmonitor_collector_version = jheader["cmonitor"]["version"]
            my_major = this_tool_version.split(".")[0]
            cmonitor_collector_major = cmonitor_collector_version.split(".")[0]
            if cmonitor_collector_major != my_major:
                print(
                    f"ERROR: the input JSON file has been generated by cmonitor_collector v{cmonitor_collector_version}, which has a different MAJOR version compared to this tool which is v{this_tool_version}."
                )
                sys.exit(10)
            elif cmonitor_collector_version != this_tool_version:
                if be_verbose:
                    print(
                        f"WARNING: the input JSON file has been generated by cmonitor_collector v{cmonitor_collector_version}, different than the version of this tool which is v{this_tool_version}."
                    )
        except KeyError:
            pass

        if len(jdata) < min_num_samples:
            print(f"Not enough data samples available; at least {min_num_samples} required. Aborting.")
            sys.exit(11)

        self.validated_json = entry
        return entry

    def get_json(self):
        return self.self.validated_json
